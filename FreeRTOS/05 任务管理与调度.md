
### **任务管理与调度的核心是链表**

- **相同优先级的任务轮流执行**
- **最高优先级的任务先运行**
	- 高优先级的任务未执行完，低任务优先级的任务无法执行
	- 一旦高优先级的任务就绪马上执行
	- 最高优先级的任务有多个，它们轮流执行

- 优先级相同的任务，后创建的先执行，因为创建任务时有一个全局指针`pxCurrentTCB`，指向最后创建的任务，启用调度器的时候会创建一个最低优先级的任务，但是这个全局指针不会指向它，因为它的的优先级低

- 相同优先级的任务会被保存在一个`ReadyTaskList`链表里面，不同优先级所形成的不同链表会被存放在一个链表数组里，每一次tick中断后，计数器就会+1（时钟基准）用于判断`DelayTaskList`里面的任务的时间是否到了，如果到了就y\移出`DelayTaskList`放到`ReadyList`里面，并发起一个调度，调度就是遍历这个链表数组（从高优先级开始向低优先级找）找出下一个要执行的任务，并让全局指针`pxCurrentTCB`指向这个要执行的任务
- `pxCurrentTCB`指向要执行的任务，`index`指针指向上一次执行的任务

-  **所有任务都是同一优先级的话，在创建新的任务时会把当前执行的任务指针指向新创建的任务，所以会先执行最后创建的任务c，下一次调度会执行c后的那个任务，没有则回到任务a，再b再c，循环

---
### 配置调度算法

所谓调度算法，就是怎么确定哪个就绪态的任务可以切换为运行状态。

通过配置文件FreeRTOSConfig.h的两个配置项来配置调度算法：configUSE_PREEMPTION、configUSE_TIME_SLICING。

还有第三个配置项：configUSE_TICKLESS_IDLE，它是一个高级选项，用于关闭Tick中断来实现省电，后续单独讲解。现在我们假设configUSE_TICKLESS_IDLE被设为0，先不使用这个功能。 调度算法的行为主要体现在两方面：高优先级的任务先运行、同优先级的就绪态任务如何被选中。调度算法要确保同优先级的就绪态任务，能"轮流"运行，策略是"轮转调度"(Round Robin Scheduling)。轮转调度并不保证任务的运行时间是公平分配的，我们还可以细化时间的分配方法。 从3个角度统一理解多种调度算法：

- 可否抢占？高优先级的任务能否优先执行(配置项: configUSE_PREEMPTION)
    - 可以：被称作"可抢占调度"(Pre-emptive)，高优先级的就绪任务马上执行，下面再细化。
    - 不可以：不能抢就只能协商了，被称作"合作调度模式"(Co-operative Scheduling)
        - 当前任务执行时，更高优先级的任务就绪了也不能马上运行，只能等待当前任务主动让出CPU资源。
        - 其他同优先级的任务也只能等待：更高优先级的任务都不能抢占，平级的更应该老实点
- 可抢占的前提下，同优先级的任务是否轮流执行(配置项：configUSE_TIME_SLICING)
    - 轮流执行：被称为"时间片轮转"(Time Slicing)，同优先级的任务轮流执行，你执行一个时间片、我再执行一个时间片
    - 不轮流执行：英文为"without Time Slicing"，当前任务会一直执行，直到主动放弃、或者被高优先级任务抢占
- 在"可抢占"+"时间片轮转"的前提下，进一步细化：空闲任务是否让步于用户任务(配置项：configIDLE_SHOULD_YIELD)
    - 空闲任务低人一等，每执行一次循环，就看看是否主动让位给用户任务
    - 空闲任务跟用户任务一样，大家轮流执行，没有谁更特殊 列表如下：

|**配置项**|**A**|**B**|**C**|**D**|**E**|
|---|---|---|---|---|---|
|configUSE_PREEMPTION|1|1|1|1|0|
|configUSE_TIME_SLICING|1|1|0|0|x|
|configIDLE_SHOULD_YIELD|1|0|1|0|x|
|说明|常用|很少用|很少用|很少用|几乎不用|

注：

- A：可抢占+时间片轮转+空闲任务让步
- B：可抢占+时间片轮转+空闲任务不让步
- C：可抢占+非时间片轮转+空闲任务让步
- D：可抢占+非时间片轮转+空闲任务不让步
- E：合作调度