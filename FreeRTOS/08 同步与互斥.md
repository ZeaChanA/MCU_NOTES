- **用全局变量实现同步的缺陷**
	- 用全局变量实现同步会占用CPU资源，因为会在任务中死等全局变量是否改变，如果是两个任务之间的同步，就会浪费掉一半的时间，正确的做法应该是等第一个任务执行完后再唤醒第二个任务
- **用全局变量实现互斥的缺陷**
	- 用全局变量实现互斥时，在判断或者修改全局变量的过程中有可能被打断，使得在这个任务运行的时候，其他任务也能同时访问同一个临界资源。解决方法可以是在判断或者修改全局变量之前把中断关掉，判断或者修改完之后再使能中断（此方法依然有缺陷，和同步一样会占用CPU资源）。


从汇编的角度来看，全局变量在多任务环境中的访问会引发竞态条件，主要是因为处理器执行指令的过程是分步的，而在这些步骤之间可能会发生任务切换或中断，导致数据不一致或错误。理解这个问题需要掌握基本的汇编操作、任务切换的时机以及中断的影响。

### 汇编级别的竞态条件

竞态条件的根源在于，处理器对全局变量的操作通常不是**原子性**的，即它们可能需要多条汇编指令完成。如果在操作尚未完成之前任务切换或中断发生，另一个任务可能会访问同一个全局变量，导致数据错误。

#### 举例：全局变量自增操作

假设一个全局变量 `counter`，我们有一个任务需要对其进行自增操作：
```c
counter = counter + 1;
```

这行 C 代码在汇编中可能会被翻译为如下的几条指令（假设是 ARM 架构）：
```c
LDR R0, [counter]   ; 从内存中加载 counter 的值到寄存器 R0
ADD R0, R0, #1      ; 将寄存器 R0 中的值加 1
STR R0, [counter]   ; 将寄存器 R0 的值存回到内存中的 counter
```

这里一共分为三步：

1.  **加载（LDR）**：将全局变量 `counter` 的当前值从内存加载到寄存器 `R0`。
2.  **增加（ADD）**：将 `R0` 中的值加 1。
3.  **存储（STR）**：将 `R0` 中的新值写回内存。

如果在这三步中的任意一步发生了任务切换或中断，另一个任务可能会读取或修改 `counter`，导致数据不一致。

#### 任务切换的竞态条件

假设当前任务1执行到 `LDR R0, [counter]`，即读取了 `counter` 的值，然后在 `ADD` 或 `STR` 之前任务被切换，此时任务2也执行类似的自增操作。这样两次修改操作没有同步，最终的结果可能是错的。例如：

-   初始 `counter` 值是 5。
-   任务1加载了 `counter = 5`，准备加 1，但还没有写回。
-   任务2也加载了 `counter = 5`，并且完成了加 1 并写回，`counter = 6`。
-   任务1被切换回来，完成了加 1 并写回，`counter = 6`。

最终，虽然两个任务都尝试自增 `counter`，但 `counter` 只增加了 1，而不是预期的 2。

### 如何避免汇编级别的竞态条件

在多任务环境中，处理器的指令在进行对共享变量的操作时会受到中断或任务切换的影响。因此，为了避免竞态条件，需要确保对全局变量的访问是**原子操作**，即整个操作不能被中断或打断。

在汇编级别，通常有以下方法来解决这个问题：

#### 1. **禁用中断**

在对全局变量进行操作前，临时禁用中断，确保操作期间不会被打断。在 ARM 架构中，可以使用以下汇编指令：
```c
CPSID I  ; 禁用中断
; 进行全局变量的修改
CPSIE I  ; 重新启用中断
```

禁用中断期间，所有中断服务程序（ISR）都会被阻止，保证当前任务能够完成对全局变量的修改。但是，这种方法只适用于短时间的关键操作，长时间禁用中断可能会影响系统性能。

#### 2. **使用互斥锁或信号量**

互斥锁或信号量是另一种常见的同步机制。在汇编级别，获取和释放互斥锁可以通过原子操作（如**LDREX/STREX** 指令对）来实现。在 ARM 架构中，互斥锁的获取和释放可能看起来像这样：
```c
; 获取互斥锁
loop:
    LDREX R0, [mutex]      ; 加载互斥锁的值
    CMP R0, #0             ; 判断互斥锁是否可用（0 表示未占用）
    STREXEQ R1, #1, [mutex] ; 如果互斥锁未被占用，将其设置为 1
    CMPEQ R1, #0           ; 如果 STREX 成功，R1 会等于 0
    BNE loop               ; 如果没有成功，重复尝试

; 进行全局变量操作

; 释放互斥锁
STR R0, [mutex]            ; 将互斥锁的值重置为 0
```

`LDREX/STREX` 指令对可以确保在加载互斥锁之后的操作不会被其他任务打断，实现原子性操作。

### 小结

在汇编级别，全局变量的访问通常需要多条指令完成，因此可能在中间某一步被打断，导致竞态条件。要避免这种情况，可以：

-   使用禁用中断的方式，确保在关键操作期间不发生任务切换。
-   使用互斥信号量等同步机制，确保多个任务对共享变量的访问是互斥的。

这些方法在不同的处理器架构上有不同的实现细节，但总体目标都是保证对全局变量的访问是原子性操作，从而避免竞态条件导致的数据错误。

---

**竞态条件**（Race Condition）是指在多任务或多线程环境中，多个线程或任务同时访问和修改共享资源时，程序的执行结果依赖于任务的执行顺序。这种情况可能导致数据不一致或程序行为异常。

### 竞态条件的本质

竞态条件通常发生在以下场景中：

1.  **共享资源**：多个任务或线程共享同一个资源，比如全局变量、文件、硬件设备等。
2.  **非原子操作**：对共享资源的访问不是原子性的，即访问操作需要分多步完成，在这多步操作过程中，其他任务可能同时访问或修改该资源。
3.  **任务切换或中断**：在某个任务执行到一半时，发生了任务切换或中断，导致另一个任务操作同一资源。

由于任务的调度顺序不确定，每次执行时不同任务对共享资源的访问可能产生不同的结果，这种不确定性就是竞态条件。

### 竞态条件的例子

#### 1. 简单的变量自增操作

假设两个任务 `Task1` 和 `Task2` 同时对全局变量 `counter` 进行自增操作：
```c
int counter = 0;

void Task1(void) {
    counter = counter + 1;
}

void Task2(void) {
    counter = counter + 1;
}
```

在汇编层面，这个操作可能会拆分为如下几步：

1.  **读取 `counter`**：将当前值从内存读取到寄存器。
2.  **增加 `1`**：在寄存器中对值进行加法操作。
3.  **写回 `counter`**：将新的值写回内存。

竞态条件发生时，`Task1` 和 `Task2` 可能同时读取 `counter` 的值，比如初始值是 `0`。这时它们都会增加 `1`，但最终 `counter` 的值可能还是 `1`，而不是预期的 `2`。这种不一致性就是竞态条件的表现。

#### 2. ATM取款的竞态条件

一个典型的竞态条件例子是多个用户同时使用ATM从同一个银行账户取款。假设账户余额为 $100，两个用户 A 和 B 同时尝试从该账户取款 $50：

1.  **用户A**：读取余额为 $100。
2.  **用户B**：也读取余额为 $100。
3.  **用户A**：完成取款操作，账户余额变为 $50。
4.  **用户B**：仍然认为余额为 $100，完成取款后，余额变为 $50（应该变为 $0）。

这里的竞态条件导致了银行账户的错误状态。

### 如何避免竞态条件

避免竞态条件的关键是确保对共享资源的访问是**同步的**，即在某个任务访问共享资源时，其他任务不能同时访问该资源。

常用的解决方法有：

#### 1. **禁用中断**

在关键操作期间，禁用中断，确保不会发生任务切换。这种方法适用于嵌入式系统，但会影响系统实时性。

#### 2. **互斥锁**

通过互斥锁（Mutex）确保一次只能有一个任务访问共享资源。在进入临界区时获取锁，操作完成后释放锁。互斥锁是一种常见的同步机制，可以有效避免竞态条件。

#### 3. **信号量**

信号量可以控制对共享资源的访问，特别适用于多个任务的协同工作。在嵌入式系统中，二值信号量通常用于保护资源或同步任务。

#### 4. **原子操作**

某些硬件或操作系统提供原子操作，即不可中断的操作。对共享资源的访问可以通过原子操作完成，避免竞态条件。

### 竞态条件的影响

竞态条件的影响包括：

-   **数据损坏**：多个任务同时修改共享资源，导致数据不一致。
-   **难以调试**：竞态条件具有随机性，可能只在特定情况下出现，难以复现和调试。
-   **安全风险**：在关键系统中，竞态条件可能导致严重的安全漏洞。

### 小结

竞态条件是一种由于任务执行顺序不确定而导致程序执行结果不一致的问题。通过使用互斥锁、信号量、禁用中断或原子操作等方法，可以有效地避免竞态条件。在多任务或多线程的开发中，识别和防止竞态条件是非常重要的。

---

**同步**和**互斥**是多任务系统中常见的两种机制，用于协调不同任务之间的行为，避免资源争用和数据不一致等问题。它们在多线程或多任务编程中经常被使用，尤其是在操作系统和实时系统中，比如 FreeRTOS。

### 1. **同步**

**同步**是指确保**多个任务在特定时刻按照预定顺序执行**。同步的目标是让某些任务协调起来，确保它们在合适的时间点执行，以实现某种逻辑或数据的正确性。一般来说，同步是为了**协调任务的执行顺序**或**等待某个条件的满足**。

#### 示例：

- **信号量**（Semaphore）：用于同步任务，当一个任务等待信号量时，它会被阻塞，直到其他任务释放信号量。这通常用来表示某个事件发生，通知其他任务可以继续执行了。
    
    **例子**：
```c
// Task 1 waits for an event (sync)
xSemaphoreTake(mySemaphore, portMAX_DELAY); // 等待信号量释放

// Task 2 signals the event (sync)
xSemaphoreGive(mySemaphore); // 释放信号量，通知 Task 1 可以继续执行
```
- **任务通知**（Task Notification）：任务可以发送和接收通知，以实现同步。一个任务可以等待通知，直到另一个任务通过发送通知来唤醒它。
    

#### 应用场景：
- 某任务需要在另一个任务完成某个操作后才能继续运行。
- 任务之间需要等待某些条件被满足时才开始运行。

### 2. **互斥**

**互斥**主要用于**保护共享资源**。当多个任务可能访问同一资源（如变量、硬件设备或内存区域）时，互斥机制确保**同一时刻只有一个任务可以访问该资源**，从而避免并发冲突和数据不一致问题。

#### 示例：

- **互斥锁**（Mutex）：是一种特殊的信号量，用于互斥。它确保在同一时刻只有一个任务可以访问共享资源，其他任务会被阻塞直到互斥锁被释放。
    
    **例子**：

```c
// Task 1 accesses shared resource
xSemaphoreTake(myMutex, portMAX_DELAY); // 获取互斥锁，独占资源
// Access shared resource
xSemaphoreGive(myMutex); // 释放互斥锁

// Task 2 also tries to access shared resource
xSemaphoreTake(myMutex, portMAX_DELAY); // 等待 Task 1 释放互斥锁
```

- **递归互斥锁**（Recursive Mutex）：允许同一任务多次获取锁，而不造成死锁，适用于递归调用场景。
    

#### 应用场景：
- 多个任务可能同时访问同一个共享资源时，使用互斥确保数据的一致性和正确性。
- 保证同一时刻只有一个任务能对某个共享资源进行读写操作。

### 同步 vs 互斥
- **同步**：是为了**协调任务的执行顺序**，保证任务之间按预定的逻辑或时间顺序执行。
- **互斥**：是为了**防止资源并发访问**，保证同一时刻只有一个任务能访问共享资源，避免冲突和数据损坏。

### 总结

- **同步**用于控制任务间的执行顺序，通过信号量、任务通知等机制实现。
- **互斥**用于保护共享资源，防止多个任务同时访问一个资源，通过互斥锁（Mutex）等机制实现。

---

在单片机开发中，常见的同步和互斥场景可以用一些任务控制的例子来说明。

### 1. **任务同步：两个任务的交替执行**

比如，你有两个任务，一个用来读取传感器数据，另一个用来处理数据并显示结果。任务1需要任务2处理完数据后，才能继续读取新数据。可以通过信号量来实现同步。

#### 代码示例：
```c
SemaphoreHandle_t dataReadySemaphore;

void Task1_ReadSensor(void *pvParameters) {
    while (1) {
        // 读取传感器数据
        ReadSensorData();
        // 释放信号量，通知Task2可以处理数据
        xSemaphoreGive(dataReadySemaphore);
        // 等待Task2处理完成
        vTaskDelay(pdMS_TO_TICKS(500));
    }
}

void Task2_ProcessData(void *pvParameters) {
    while (1) {
        // 等待Task1读取数据
        if (xSemaphoreTake(dataReadySemaphore, portMAX_DELAY) == pdTRUE) {
            // 处理传感器数据
            ProcessSensorData();
        }
    }
}

int main(void) {
    dataReadySemaphore = xSemaphoreCreateBinary();
    xTaskCreate(Task1_ReadSensor, "Task1", 1000, NULL, 1, NULL);
    xTaskCreate(Task2_ProcessData, "Task2", 1000, NULL, 1, NULL);
    vTaskStartScheduler();
}
```

### 2. **任务互斥：串口资源保护**

两个任务要共享同一个串口进行通信，但一次只能有一个任务使用串口，这种情况下就需要用互斥量来防止资源竞争。

#### 代码示例：
```c
SemaphoreHandle_t uartMutex;

void Task1_SendData(void *pvParameters) {
    while (1) {
        // 获取串口资源
        if (xSemaphoreTake(uartMutex, portMAX_DELAY) == pdTRUE) {
            // 使用串口发送数据
            SendUART("Task 1 sending data");
            // 释放串口资源
            xSemaphoreGive(uartMutex);
        }
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

void Task2_SendData(void *pvParameters) {
    while (1) {
        // 获取串口资源
        if (xSemaphoreTake(uartMutex, portMAX_DELAY) == pdTRUE) {
            // 使用串口发送数据
            SendUART("Task 2 sending data");
            // 释放串口资源
            xSemaphoreGive(uartMutex);
        }
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

int main(void) {
    uartMutex = xSemaphoreCreateMutex();
    xTaskCreate(Task1_SendData, "Task1", 1000, NULL, 1, NULL);
    xTaskCreate(Task2_SendData, "Task2", 1000, NULL, 1, NULL);
    vTaskStartScheduler();
}
```
在这两个例子中，第一个通过信号量进行同步，第二个通过互斥量进行资源保护，这些都是实际开发中常见的操作。

也可以使用二值信号量来实现串口资源保护，虽然互斥量通常用于这种场景，因为它可以自动处理优先级继承，防止优先级反转问题，但如果不考虑优先级继承，二值信号量也可以用来保护共享资源。下面是使用二值信号量实现串口资源保护的代码示例。

### 代码示例：
```c
// 定义二值信号量句柄
SemaphoreHandle_t uartBinarySemaphore;

void Task1_SendData(void *pvParameters) {
    while (1) {
        // 尝试获取串口资源（即二值信号量）
        if (xSemaphoreTake(uartBinarySemaphore, portMAX_DELAY) == pdTRUE) {
            // 使用串口发送数据
            SendUART("Task 1 sending data");
            // 释放串口资源（释放信号量）
            xSemaphoreGive(uartBinarySemaphore);
        }
        vTaskDelay(pdMS_TO_TICKS(1000));  // 任务延时
    }
}

void Task2_SendData(void *pvParameters) {
    while (1) {
        // 尝试获取串口资源（即二值信号量）
        if (xSemaphoreTake(uartBinarySemaphore, portMAX_DELAY) == pdTRUE) {
            // 使用串口发送数据
            SendUART("Task 2 sending data");
            // 释放串口资源（释放信号量）
            xSemaphoreGive(uartBinarySemaphore);
        }
        vTaskDelay(pdMS_TO_TICKS(1000));  // 任务延时
    }
}

int main(void) {
    // 创建二值信号量
    uartBinarySemaphore = xSemaphoreCreateBinary();

    // 初始化时释放信号量，表示资源可用
    xSemaphoreGive(uartBinarySemaphore);

    // 创建任务
    xTaskCreate(Task1_SendData, "Task1", 1000, NULL, 1, NULL);
    xTaskCreate(Task2_SendData, "Task2", 1000, NULL, 1, NULL);

    // 启动调度器
    vTaskStartScheduler();

    // 不会到达这里
    for (;;) {}
}
```
### 代码说明：

- `xSemaphoreCreateBinary()` 创建二值信号量，表示串口资源的占用情况。
- `xSemaphoreGive()` 用于释放信号量，即表示资源可用。
- `xSemaphoreTake()` 用于获取信号量，即尝试占用串口资源。

### 工作原理：

- 在初始化时通过 `xSemaphoreGive()` 释放信号量，表示串口资源空闲。
- 当任务需要使用串口时，它会尝试通过 `xSemaphoreTake()` 获取信号量。如果信号量可用（即资源空闲），任务将成功获取并执行串口通信。
- 任务完成通信后通过 `xSemaphoreGive()` 释放信号量，表示资源重新可用。

这样，任务1和任务2就不会同时访问串口资源，从而避免资源冲突。

---
在嵌入式系统中，`for (;;) {}` 这一行代码的作用主要是为了确保程序不会意外退出到不应该到达的地方。它充当一个无限循环，通常用于以下目的：

### 1. **防止程序结束：**

在 `main` 函数中，调用 `vTaskStartScheduler()` 启动了 FreeRTOS 的任务调度器。调度器会接管处理器控制权并开始执行任务。`vTaskStartScheduler()` 一般不会返回，除非发生了错误或系统被重置。因此，为了确保如果 `vTaskStartScheduler()` 出于某种原因返回时，程序不会继续执行后面的代码，通常会在 `main` 函数中加入一个无限循环。

### 2. **占用处理器资源：**

在一些嵌入式系统中，如果 `vTaskStartScheduler()` 返回，那么处理器将会进入一个未知状态，可能会导致意外的行为。通过 `for (;;) {}` 无限循环，可以确保处理器在调试期间不会执行到意外的代码路径，并且能够让系统保持在一个已知的状态。

### 3. **调试和错误处理：**

有时在开发和调试阶段，`for (;;) {}` 也可以作为错误处理的一部分。如果 `vTaskStartScheduler()` 返回，通常意味着存在严重的错误，程序应当停在无限循环中，等待调试或系统重启。这可以帮助开发人员捕获和诊断问题。

### 代码示例：
```c
int main(void) {
    // 创建任务、初始化硬件等
    
    // 启动调度器
    vTaskStartScheduler();

    // 如果调度器返回，程序将进入无限循环，防止执行到不应该到达的地方
    for (;;) {
        // 可以在这里进行调试或错误处理
    }
}
```
简而言之，`for (;;) {}` 主要是作为一种防御性编程实践，确保在 FreeRTOS 调度器启动后，如果出现问题，系统不会意外地执行到不应执行的代码。

---
## 各类方法的对比

能实现同步、互斥的内核方法有：任务通知(task notification)、队列(queue)、事件组(event group)、信号量(semaphoe)、互斥量(mutex)。

它们都有类似的操作方法：获取/释放、阻塞/唤醒、超时。比如：

- 任务A获取资源，用完后任务A释放资源
- 任务A获取不到资源则阻塞，任务B释放资源并把任务A唤醒
- 任务A获取不到资源则阻塞，并定个闹钟；A要么超时返回，要么在这段时间内因为任务B释放资源而被唤醒。

这些内核对象五花八门，记不住怎么办？我也记不住，通过对比的方法来区分它们。

- 能否传信息？还是只能传递状态？
- 为众生（所有任务都可以使用）？只为你（只能指定任务使用）？
- 我生产，你们消费？
- 我上锁，只能由我开锁

|**内核对象**|**生产者**|**消费者**|**数据/状态**|**说明**|
|---|---|---|---|---|
|队列|ALL|ALL|数据：若干个数据 谁都可以往队列里扔数据， 谁都可以从队列里读数据|用来传递数据， 发送者、接收者无限制， 一个数据只能唤醒一个接收者|
|事件组|ALL|ALL|多个位：或、与 谁都可以设置(生产)多个位， 谁都可以等待某个位、若干个位|用来传递事件， 可以是N个事件， 发送者、接受者无限制， 可以唤醒多个接收者：像广播|
|信号量|ALL|ALL|数量：0~n 谁都可以增加一个数量， 谁都可消耗一个数量|用来维持资源的个数， 生产者、消费者无限制， 1个资源只能唤醒1个接收者|
|任务通知|ALL|只有我|数据、状态都可以传输， 使用任务通知时， 必须指定接受者|N对1的关系： 发送者无限制， 接收者只能是这个任务|
|互斥量|只能A开锁|A上锁|位：0、1 我上锁：1变为0， 只能由我开锁：0变为1|就像一个空厕所， 谁使用谁上锁， 也只能由他开锁|

使用图形对比如下：

- 队列：
    
    - 里面可以放任意数据，可以放多个数据
    - 任务、ISR都可以放入数据；任务、ISR都可以从中读出数据
- 事件组：
    
    - 一个事件用一bit表示，1表示事件发生了，0表示事件没发生
    - 可以用来表示事件、事件的组合发生了，不能传递数据
    - 有广播效果：事件或事件的组合发生了，等待它的多个任务都会被唤醒
- 信号量：
    
    - 核心是"计数值"
    - 任务、ISR释放信号量时让计数值加1
    - 任务、ISR获得信号量时，让计数值减1
- 任务通知：
    
    - 核心是任务的TCB里的数值
    - 会被覆盖
    - 发通知给谁？必须指定接收任务
    - 只能由接收任务本身获取该通知
- 互斥量：
    
    - 数值只有0或1
    - 谁获得互斥量，就必须由谁释放同一个互斥量

![[Pasted image 20240910234134.png]]