**中断向量表**中的每个中断源对应一个中断服务例程（ISR）的地址。中断向量表是一个存储这些地址的数组或列表，CPU在发生中断时，会使用中断向量表来找到正确的ISR并执行。

### 中断向量表的工作原理：

1.  **中断触发**：当某个中断源（如外部设备或定时器）触发中断时，中断控制器会向CPU发送一个中断请求。
    
2.  **中断响应**：CPU在完成当前指令后，会检查中断标志位，如果检测到有中断请求，会进入中断处理流程。
    
3.  **查找ISR地址**：
    
    -   CPU会根据中断请求的类型（通常是中断号）来查找中断向量表。
    -   中断向量表中的每个条目对应一个特定的中断源，这些条目存储了ISR的地址。
4.  **执行ISR**：找到相应的ISR地址后，CPU会跳转到该地址开始执行ISR的代码。
    
5.  **返回**：ISR执行完毕后，CPU会恢复之前保存的状态，返回到被中断的程序继续执行。
    

### 示例

假设有一个简单的中断向量表:
```c
#define NUM_INTERRUPTS 10

void (*interrupt_vector[NUM_INTERRUPTS])(void); // 中断向量表

// 示例ISR
void TimerISR(void) {
    // 处理定时器中断
}

// 初始化中断向量表
void setupInterrupts() {
    interrupt_vector[0] = TimerISR; // 定时器中断
    // 其他中断源的初始化
}
```

在这个例子中，`interrupt_vector`数组存储了不同中断源的ISR地址。当定时器中断触发时，CPU会根据中断号（这里是0）找到`TimerISR`的地址并执行它。

### 总结

中断向量表中的中断源确实是中断响应函数（ISR）的地址，允许CPU在发生中断时快速找到并执行对应的ISR，从而响应外部事件或内部条件。